---
title: 04-redis常见问题
description: redis常见问题收集
published: true
date: 2023-09-14T08:58:24.574Z
tags: redis, 咕泡, 面试
editor: markdown
dateCreated: 2023-09-08T09:40:11.104Z
---

# 04-redis常见问题
 
 ## 01 对redis的理解
 1. Redis 是一个高性能的基于 Key-Value 结构存储的 Nosql 开源数据库。
 2. 一般采用 Redis 来实现分布式缓存，从而提高数据的检索效率。
 3. Redis 之所以这么流行，主要有几个特点：
   - 基于内存存储，在进行数据 IO 操作时，能够 10WQPS
   - 提供了非常丰富的数据存储结构，如 String、List、Hash、Set、ZSet 等。
   -  底层采用单线程实现数据的 IO，所以在数据算法层面并不需要要考虑并发安全性，所以底层算法上的时间复杂度基本上都是常量
4. Redis 虽然是内存存储，但是它也可以支持持久化，避免因为服务器故障导致数据丢失的问题

`基于这些特点，Redis 一般用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响。除此之外，Redis 还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供非常方便和成熟的解决方案`

## 02 Redis 为什么这么快
1. 决定 Redis 请求效率的因素主要是三个方面，分别是网络、cpu、内存。
2. 在网络层面，Redis 采用**多路复用**的设计，提升了并发处理的连接数，不过这个阶段，Server 端的所有 IO 操作，都是由同一个主线程处理的这个时候 IO 的瓶颈就会影响到 Redis 端的整体处理性能。所以从 Redis6.0 开始，在多路复用及层面增加了多线程的处理，来优化 IO 处理的能力。不过，具体的数据操作仍然是由主线程来处理的，所以我们可以认为 Redis 对于数据 IO的处理依然是单线程。
3. 从 CPU 层面来说，Redis 只需要采用单线程即可，原因有两个。
 - 3.1 如果采用多线程，对于 Redis 中的数据操作，都需要通过同步的方式来保证线程安全性，这反而会影响到 redis 的性能
 - 3.2 在 Linux 系统上 Redis 通过 pipelining 可以处理 100w 个请求每秒，而应用程序的计算复杂度主要是 O(N) 或 O(log(N)) ，不会消耗太多 CPU；
4.  从内存层面来说，Redis 本身就是一个内存数据库，内存的 IO 速度本身就很快，所以内存的瓶颈只是受限于内存大小
5. 最后， Redis 本身的数据结构也做了很多的优化，比如压缩表、跳跃表等方式降低了时间复杂读，同时还提供了不同时间复杂度的数据类型。使得开发人员能够有更多合适的选择。

## 03 Redis 和 Mysql 如何保证数据一致性
1. 一般先更新数据库，再更新缓存，或者 先删除缓存，再更新数据库，但是都可能存在不一致性
2. 在极端情况下仍然保证 Redis 和 Mysql 的数据一致性，就只能采用最终一致性方案。
  - 2.1 比如基于 RocketMQ 的可靠性消息通信，来实现最终一致性。（更新失败的请求写入mq，同步到redis）
  - 2.2 直接通过 Canal 组件，监控 Mysql 中 binlog 的日志，把更新后的数据同步到 Redis 里面。
3. 通过读写锁的方式来保证强一致性  ：在数据更新的时候，其他任何请求都无法访问缓存中的数据，直到数据更新完毕，从而保证了数据的强一致性

## 04 Redis 存在线程安全问题吗
1. Redis Server 本身是一个线程安全的 K-V 数据库，也就是说在 Redis Server 上执行的指令，不需要任何同步机制，不会存在线程安全问题。
2. Redis 6.0 里面，增加了多线程的模型，但是增加的多线程只是用来处理网络 IO 事件，对于指令的执行过程，仍然是由主线程来处理，所以不会存在多个线程通知执行操作指令的情况。
` Redis 没有采用多线程来执行指令，有几个方面的原因:`
  - 2.1 Redis Server 本身可能出现的性能瓶颈点无非就是网络 IO、CPU、内存。但是 CPU不是 Redis 的瓶颈点，所以没必要使用多线程来执行指令。
  - 如果采用多线程，意味着对于 redis 的所有指令操作，都必须要考虑到线程安全问题，也就是说需要加锁来解决，这种方式带来的性能影响反而更大。
3. 从 Redis 客户端层面:虽然 Redis Server 中的指令执行是原子的，但是如果有多个 Redis 客户端同时执行多个指令的时候，就无法保证原子性。
`对于客户端层面的线程安全性问题，解决方法有很多，比如尽可能的使用 Redis里面的原子指令(SETNX/GETSET/INCR/DECR/MSET/MSETNX/HSET/MSETNX/LPUSH/RPUSH)，或者对多个客户端的资源访问加锁，或者通过 Lua 脚本来实现多个指令的操作等等。` 

## 05 RDB 和 AOF 的实现原理以及优缺点
1. 两种持久化机制的特性：RDB 是通过快照方式实现持久化、AOF 是通过命令追加的方式实现持久化。
2. 两种机制的工作原理：
  - 2.1 RDB 持久化机制会根据快照触发条件，把内存里面的数据快照写入到磁盘，以二进制的压缩文件进行存储。
     - RDB 快照的触发方式:
     - 执行 bgsave 命令触发异步快照，执行 save 命令触发同步快照，同步快照会阻塞客户端的执行指令。
     - 根据 redis.conf 文件里面的配置，自动触发 bgsave
     - 主从复制的时候触发
  - 2.2  AOF 持久化机制是近乎实时的方式来完成持久化的，就是客户端执行一个数据变更的操作，Redis Server 就会把这个命令追加到 aof 缓冲区的末尾，然后再把缓冲区的数据写入到磁盘的 AOF 文件里面，至于最终什么时候真正持久化到磁盘，是根据刷盘的策略来决定的。
    - 为了避免追加的方式导致 AOF 文件过大的问题，Redis 提供了 AOF 重写机制,当 AOF 文件的大小达到某个阈值的时候，就会把这个文件里面相同的指令进
行压缩。
3. AOF 和 RDB 的优缺点:
  - 3.1 RDB 是每隔一段时间触发持久化，因此数据安全性低，AOF 可以做到实时持久化，数据安全性较高
  - 3.2 RDB 文件默认采用压缩的方式持久化，AOF 存储的是执行指令，所以 RDB 在数据恢复的时候性能比 AOF 要好
4. (RDB和AOF到底该如何选择)[https://juejin.cn/post/6926039904590037005]:
  - 4.1 

## 06 Redis 的内存淘汰算法和原理
1. Redis 里面的内存淘汰策略，是指内存的使用率达到 maxmemory 上限的时候的一种内存释放的行为。
2. 提供了很多中内存淘汰算法，归纳起来主要就四种：
  - 2.1  Random 算法，随机移除某个 key
  - 2.2  TTL 算法 ，在设置了过期时间的键中，把更早过期时间的 key 有限移除
  - 2.3  LRU 算法，移除最近很少使用的 key
  - 2.4  LFU 算法，移除最近很少使用的 key。 多了访问频率维度的统计

## 07 分布式锁的理解和实现
1. 分布式锁，是一种跨进程的跨机器节点的互斥锁，它可以用来保证多机器节点对于共享资源访问的排他性。
2. 分布式锁和线程锁本质上是一样的，都需要满足锁的几个重要特性：
  - 2.1 排他性，也就是说，同一时刻只能有一个节点去访问共享资源。
  - 2.2 可重入性，允许一个已经获得锁的进程，在没有释放锁之前再次重新获得锁。
  - 2.3 锁的获取、释放的方法
  - 2.4 锁的失效机制，避免死锁的问题
  > 只要能够满足这些特性的技术组件都能够实现分布式锁。
3. Redis，它里面提供了 SETNX 命令可以实现锁的排他性，当 key 不存在就返回 1，存在就返回 0。然后还可以用 expire 命令设置锁的失效时间，从而避免死锁问题。当然有可能存在锁过期了，但是业务逻辑还没执行完的情况。 所以这种情况，可以写一个定时任务对指定的 key 进行续期.
4. Redisson 这个开源组件，就提供了分布式锁的封装实现，并且也内置了一个 WatchDog 机制来对 key 做续期。
5. 如果在 Redis搭建了高可用集群的情况下出现主从切换导致 key 失效，这个问题也有可能造成多个线程抢占到同一个锁资源的情况，所以 Redis 官方也提供了一个 RedLock 的解决办法，但是实现会相对复杂一些。
6. 分布式锁应该是一个 CP 模型，而 Redis 是一个 AP 模型，所以在集群架构下由于数据的一致性问题导致极端情况下出现多个线程抢占到锁的情况很难避免。
7. 那么基于 CP 模型又能实现分布式锁特性的组件，我认为可以选择 Zookeeper 或者etcd，在数据一致性方面，zookeeper 用到了 zab 协议来保证数据的一致性，etcd用到了 raft 算法来保证数据一致性。在锁的互斥方面，zookeeper 可以基于有序节点再结合 Watch 机制实现互斥和唤醒，etcd 可以基于 Prefix 机制和 Watch 实现互斥和唤醒。


## 08 缓存雪崩和缓存穿透的理解，以及如何避免
1. **缓存雪崩**： 缓存里面的大量数据，在**同一个时刻全部过期**，原本缓存组件抗住的大部分流量全部**请求到了数据库**。导致数据库压力增加造成数据库服务器崩溃的现象。
 - 雪崩的原因：
 - 1.1 缓存中间件宕机，当然可以对缓存中间件做高可用集群来避免
 - 1.2 缓存中大部分 key 都设置了相同的过期时间，导致同一时刻这些 key 都过期了。对于这样的情况，可以在失效时间上增加一个 1 到 5 分钟的随机值。
2. **缓存穿透** ：短时间内有**大量的不存在的 key 请求到应用里面**，而这些不存在的 key 在缓存里面又找不到，从而全部穿透到了数据库，造成数据库压力。
  - 2.1 这个场景的核心问题是针对缓存的一种攻击行为，正常的业务里面，即便是出现了这样的情况，由于缓存的不断预热，影响不会很大。
  - 2.2 攻击行为就需要具备时间是的持续性，而只有 key 确实在数据库里面也不存在的情况下，才能达到这个目的，所以，我认为有两个方法可以解决：
    - 2.2.1 把无效的 key 也保存到 Redis 里面，并且设置一个特殊的值，比如“null”，这样的话下次再来访问，就不会去查数据库了
    - 2.2.2 布隆过滤器来实现，在系统启动的时候把目标数据全部缓存到布隆过滤器里面，当攻击者用不存在的 key 来请求的时候，先到布隆过滤器里面查询，如果不存在，那意味着这个 key 在数据库里面也不存在。（它采用了 bitmap 来进行数据存储，占用的内存空间很少。）
3. 不用放大雪崩和穿透的影响，因为：
  - 3.1 在一个成熟的系统里面，对于比较重要的热点数据，必然会有一个专门缓存系统来维护，同时它的过期时间的维护必然和其他业务的 key 会有一定的差别。而且非常重要的场景，我们还会设计多级缓存系统。
  - 3.2 即便是触发了缓存雪崩，数据库本身的容灾能力也并没有那么脆弱，数据库的主从、双主、读写分离这些策略都能够很好的缓解并发流量。
  - 3.3 ，数据库本身也有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制，也能够很好的保护数据库系统，最多就是造成部分用户体验不好。
  - 3.4 另外，在程序设计上，为了避免缓存未命中导致大量请求穿透到数据库的问题，还可以在访问数据库这个环节加锁。虽然影响了性能，但是对系统是安全的。
  
## 09 Redis 中 AOF 重写的过程
1. AOF 是 Redis 里面的一种数据持久化方式，它采用了指令追加的方式近乎实时的去实现数据指令的持久化，因为 AOF，会把每个数据更改的操作指令，追加存储到 aof 文件里面。所以很容易导致 AOF 文件出现过大，造成 IO 性能问题。
2. Redis 为了解决这个问题，设计了 AOF 重写机制，也就是说把 AOF 文件里面相同的指令进行压缩，只保留最新的数据指令。
3. 简单来说，如果 aof 文件里面存储了某个 key 的多次变更记录，但是实际上，最终在做数据恢复的时候，只需要执行最新的指令操作就行了，历史的数据就没必要存在这个文件里面占空间。
4. AOF 文件重写的具体过程：、
  - 4.1 根据当前 Redis 内存里面的数据，重新构建一个新的 AOF 文件，
  - 4.2 读取当前 Redis 里面的数据，写入到新的 AOF 文件里面
  - 4.3 重写完成以后，用新的 AOF 文件覆盖现有的 AOF 文件
  - 4.4 另外，因为 AOF 在重写的过程中需要读取当前内存里面所有的键值数据，再生成对应的一条指令进行保存。而这个过程是比较耗时的，对业务会产生影响。所以 Redis 把重写的过程放在一个后台子进程里面来完成，这样一来，子进程在做重写的时候，主进程依然可以继续处理客户端请求。
  - 4.5 最后，为了避免子进程在重写过程中，主进程的数据发生变化，导致 AOF 文件和 Redis 内存中的数据不一致的问题，Redis 还做了一层优化。就是子进程在重写的过程中，主进程的数据变更需要追加到 AOF 重写缓冲区里面。等到 AOF 文件重写完成以后，再把 AOF 重写缓冲区里面的内容追加到新的 AOF 文件里面。
  
## 10 Redis 的缓存淘汰策略
1.  当 Redis 使用的内存达到 maxmemory 参数配置的阈值的时候，Redis 就会根据配置的内存淘汰策略。把访问频率不高的 key 从内存中移除。maxmemory 默认情况是当前服务器的最大内存。
2.   Redis 默认提供了 8 种缓存淘汰策略，这 8 种缓存淘汰策略总的来说，我认为可以归类成五种:
  - 2.1 采用 LRU 策略，就是把不经常使用的 key 淘汰掉
  - 2.2 采用 LFU 策略，它在 LRU 算法上做了优化，增加了数据访问次数，从而确保淘汰的是非热点 key。
  - 2.3 随机策略，也就是是随机删除一些 key
  - 2.4 ttl 策略，从设置了过期时间的 key 里面，挑选出过期时间最近的 key 进行优先淘汰
  - 2.5 当内存不够的时候，直接报错，这是默认的策略。
3.   我们在使用缓存的时候，建议是增加这些缓存的过期时间。因为我们知道这些缓存大概的生命周期，从而更好的利用内存。

## 11 Redis 哨兵机制和集群有什么区别
1. Redis 哨兵集群是基于主从复制来实现的，所以它可以实现读写分离，分担 Redis读操作的压力
2.  Redis Cluster 集群的 Slave 节点只是实现冷备机制，它只有在 Master 宕机之后才会工作。
3. Redis 哨兵集群无法在线扩容，所以它的并发压力受限于单个服务器的资源配置。
4. Redis Cluster 提供了基于 Slot 槽的数据分片机制，可以实现在线扩容提升写数据的性能
5. 从集群架构上来说，Redis 哨兵集群是一主多从， 而 Redis Cluster 是多主多从

## 12 Redis 主从复制的原理
1. Redis 主从复制，是指在 Redis 集群里面），Master 节点和 Slave 节点数据同步的一种机制
2. 在 Redis 里面，提供了**全量复制**和**增量复制**两种模式。
3. 全量复制一般发生在 Slave 节点初始化阶段，这个时候需要把 master 上所有数据都制一份。原理如下：
  - 3.1 Slave 向 Master 发送 SYNC 命令，Master 收到命令以后生成数据快照
  - 3.2 把快照数据发送给 Slave 节点，Salve 节点收到数据后丢弃旧的数据，并重新载入新的数据
  - 3.3 需要注意，在主从复制过程中，Redis 并没有采用实现强数据一致性，因此会存在一定时间的数据不一致问题。
4. 增量复制，就是指 Master 收到数据变更之后，把变更的数据同步给所有 Slave 节点。  
  - 4.4 增量复制的原理是，Master 和 Slave 都会维护一个复制偏移量（offset），用来表示Master 向 Slave 传递的字节数
  - 4.5 每次传输数据，Master 和 Slave 维护的 Offset 都会增加对应的字节数量。Redis 只需要根据 Offset 就可以实现增量数据同步了。
  
## 13 Redis 遇到 Hash 冲突怎么办
1. 所谓 hash 冲突，是指不同的 key，计算出来的结果落到了同一个 hash 桶中。
2. Redis 为了解决哈希冲突，采用了链式寻址法，也就是采用链表的方式来保存同一个hash 桶中的多个元素。（和 Java 中的 HashMap 是一样的。）
3. 如果出现大量的 key 的冲突导致链表过长的情况下，会导致数据的检索效率变慢，Redis 是怎么解决这个问题的呢？
4. 为了保持高效，Redis 会对哈希表做 rehash 操作，也就通过增加哈希桶来减少冲突。
5. 为了 rehash 更高效，Redis 还默认使用了两个全局哈希表，一个用于当前使用，称为主哈希表，一个用于扩容，称为备用哈希表

## 14 Redis 中的哨兵选举算法是如何实现的
1. **筛选**:
  - 在筛选阶段，会过滤掉不健康的节点，比如（下线或者断线），或者没有回复 Sentinel哨兵心跳响应的 Slave 节点。同时，还会评估实例过往的网络连接情况，如果在一定时间内，Slave 和 Master 经常性断链，而且超出了一定的阈值，也不会考虑。经过筛选后，留下的都是健康的节点了。
2. **综合评估**  :
  - 2.1 根据 Slave 优先级来判断，通过 slave-priority 配置项（redis.conf），可以给不同的从库设置不同优先级，优先级高的优先成为 master。 
  - 2.2 选择数据偏移量差距最小的，即 slave_repl_offset 与 master_repl_offset 进度差距，其实就是比较 slave 与 原 master 复制进度差距，避免丢失过多数据的问题。
  - 2.3 slave runID，在优先级和复制进度都相同的情况下，选用 runID 最好的，runID越小说明创建时间越早，优先选为 master。
3.   如果哨兵存在集群的情况下，如果其中一个哨兵节点认为 Redis 集群主线故障，另外两个哨兵还没感知到的情况下。在进行 Master 选举之前，Sentinel 哨兵集群需要通过共识算法来达成一致，这里用到了 Raft 协议。

