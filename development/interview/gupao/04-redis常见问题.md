---
title: 04-redis常见问题
description: redis常见问题收集
published: true
date: 2023-09-11T10:00:16.279Z
tags: redis, 咕泡, 面试
editor: markdown
dateCreated: 2023-09-08T09:40:11.104Z
---

# 04-redis常见问题
 
 ## 01 对redis的理解
 1. Redis 是一个高性能的基于 Key-Value 结构存储的 Nosql 开源数据库。
 2. 一般采用 Redis 来实现分布式缓存，从而提高数据的检索效率。
 3. Redis 之所以这么流行，主要有几个特点：
   - 基于内存存储，在进行数据 IO 操作时，能够 10WQPS
   - 提供了非常丰富的数据存储结构，如 String、List、Hash、Set、ZSet 等。
   -  底层采用单线程实现数据的 IO，所以在数据算法层面并不需要要考虑并发安全性，所以底层算法上的时间复杂度基本上都是常量
4. Redis 虽然是内存存储，但是它也可以支持持久化，避免因为服务器故障导致数据丢失的问题

`基于这些特点，Redis 一般用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响。除此之外，Redis 还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供非常方便和成熟的解决方案`

## 02 Redis 为什么这么快
1. 决定 Redis 请求效率的因素主要是三个方面，分别是网络、cpu、内存。
2. 在网络层面，Redis 采用**多路复用**的设计，提升了并发处理的连接数，不过这个阶段，Server 端的所有 IO 操作，都是由同一个主线程处理的这个时候 IO 的瓶颈就会影响到 Redis 端的整体处理性能。所以从 Redis6.0 开始，在多路复用及层面增加了多线程的处理，来优化 IO 处理的能力。不过，具体的数据操作仍然是由主线程来处理的，所以我们可以认为 Redis 对于数据 IO的处理依然是单线程。
3. 从 CPU 层面来说，Redis 只需要采用单线程即可，原因有两个。
 - 3.1 如果采用多线程，对于 Redis 中的数据操作，都需要通过同步的方式来保证线程安全性，这反而会影响到 redis 的性能
 - 3.2 在 Linux 系统上 Redis 通过 pipelining 可以处理 100w 个请求每秒，而应用程序的计算复杂度主要是 O(N) 或 O(log(N)) ，不会消耗太多 CPU；
4.  从内存层面来说，Redis 本身就是一个内存数据库，内存的 IO 速度本身就很快，所以内存的瓶颈只是受限于内存大小
5. 最后， Redis 本身的数据结构也做了很多的优化，比如压缩表、跳跃表等方式降低了时间复杂读，同时还提供了不同时间复杂度的数据类型。使得开发人员能够有更多合适的选择。

## 03 Redis 和 Mysql 如何保证数据一致性
1. 一般先更新数据库，再更新缓存，或者 先删除缓存，再更新数据库，但是都可能存在不一致性
2. 在极端情况下仍然保证 Redis 和 Mysql 的数据一致性，就只能采用最终一致性方案。
  - 2.1 比如基于 RocketMQ 的可靠性消息通信，来实现最终一致性。（更新失败的请求写入mq，同步到redis）
  - 2.2 直接通过 Canal 组件，监控 Mysql 中 binlog 的日志，把更新后的数据同步到 Redis 里面。
3. 通过读写锁的方式来保证强一致性  ：在数据更新的时候，其他任何请求都无法访问缓存中的数据，直到数据更新完毕，从而保证了数据的强一致性

## 04 Redis 存在线程安全问题吗
1. Redis Server 本身是一个线程安全的 K-V 数据库，也就是说在 Redis Server 上执行的指令，不需要任何同步机制，不会存在线程安全问题。
2. Redis 6.0 里面，增加了多线程的模型，但是增加的多线程只是用来处理网络 IO 事件，对于指令的执行过程，仍然是由主线程来处理，所以不会存在多个线程通知执行操作指令的情况。
` Redis 没有采用多线程来执行指令，有几个方面的原因:`
  - 2.1 Redis Server 本身可能出现的性能瓶颈点无非就是网络 IO、CPU、内存。但是 CPU不是 Redis 的瓶颈点，所以没必要使用多线程来执行指令。
  - 如果采用多线程，意味着对于 redis 的所有指令操作，都必须要考虑到线程安全问题，也就是说需要加锁来解决，这种方式带来的性能影响反而更大。
3. 从 Redis 客户端层面:虽然 Redis Server 中的指令执行是原子的，但是如果有多个 Redis 客户端同时执行多个指令的时候，就无法保证原子性。
`对于客户端层面的线程安全性问题，解决方法有很多，比如尽可能的使用 Redis里面的原子指令(SETNX/GETSET/INCR/DECR/MSET/MSETNX/HSET/MSETNX/LPUSH/RPUSH)，或者对多个客户端的资源访问加锁，或者通过 Lua 脚本来实现多个指令的操作等等。` 

## 05 RDB 和 AOF 的实现原理以及优缺点
1. 两种持久化机制的特性：RDB 是通过快照方式实现持久化、AOF 是通过命令追加的方式实现持久化。
2. 两种机制的工作原理：
  - 2.1 RDB 持久化机制会根据快照触发条件，把内存里面的数据快照写入到磁盘，以二进制的压缩文件进行存储。
     - RDB 快照的触发方式:
     - 执行 bgsave 命令触发异步快照，执行 save 命令触发同步快照，同步快照会阻塞客户端的执行指令。
     - 根据 redis.conf 文件里面的配置，自动触发 bgsave
     - 主从复制的时候触发
  - 2.2  AOF 持久化机制是近乎实时的方式来完成持久化的，就是客户端执行一个数据变更的操作，Redis Server 就会把这个命令追加到 aof 缓冲区的末尾，然后再把缓冲区的数据写入到磁盘的 AOF 文件里面，至于最终什么时候真正持久化到磁盘，是根据刷盘的策略来决定的。
    - 为了避免追加的方式导致 AOF 文件过大的问题，Redis 提供了 AOF 重写机制,当 AOF 文件的大小达到某个阈值的时候，就会把这个文件里面相同的指令进
行压缩。
3. AOF 和 RDB 的优缺点:
  - 3.1 RDB 是每隔一段时间触发持久化，因此数据安全性低，AOF 可以做到实时持久化，数据安全性较高
  - 3.2 RDB 文件默认采用压缩的方式持久化，AOF 存储的是执行指令，所以 RDB 在数据恢复的时候性能比 AOF 要好
4. (RDB和AOF到底该如何选择)[https://juejin.cn/post/6926039904590037005]:
  - 4.1 



