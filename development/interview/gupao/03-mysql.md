---
title: 03-MYSQL常见面试题
description: MYSQL常见面试题
published: true
date: 2023-08-25T08:50:38.110Z
tags: 咕泡, 面试
editor: markdown
dateCreated: 2023-08-23T07:11:38.907Z
---

# 03-MYSQL常见面试题

## 01 innoDB 如何解决幻读
[MySQL 幻读被彻底解决了吗★](https://blog.csdn.net/m0_71777195/article/details/126968432)
1. MYSQL的事务隔离级别：代表当存在多个事务并发冲突时，可能出现的脏读、不可重复读、幻读的问题。 (×：会差生，√：不会产生)
  | 事务隔离级别        | 脏读 |  不可重复读 | 幻读 | 
  |---                |---  | ---        | --- |
  | Read Uncommitted  |   √ |    √       | √   |
  | Read committed    |   × |    √       |  √  |
  | repeated read     |  ×  |    ×       |  很大程度避免  |
  | serializable      |   × |    ×       |  × |
  
2. 当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。
3. MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
   - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

> **快照读是如何避免幻读的？**
> 可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个  Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

> **当前读是如何避免幻读的？**
> MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。
这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。
另外，select ... for update 这种查询语句是当前读，每次执行的时候都是读取最新的数据。


3. 小结:
 - MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：
  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。
 - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。
> **举例了两个发生幻读场景的例子**。
> **第一个例子**：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。
**第二个例子**：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。
- 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。
- 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。

## 02 MYSQL性能优化
1. **硬件和操作系统层面的优化**
>  CPU、可用内存大小、磁盘读写速度、网络带宽
2. **架构设计层面的优化**
> MySQL 是一个磁盘 IO 访问量非常频繁的关系型数据库:
> 1. 搭建 Mysql 主从集群
> 2. 读写分离设计
> 3. 分库分表机制
> 4. 热点数据缓存
3.  **MySQL 程序配置优化**
>  my.cnf 中, 比如最大连接数， 开启binlog 日志，bufferPool等
>  注意：作用域
4.  **SQL 优化**
  - 4.1 慢 SQL 的定位和排查： 以通过慢查询日志和慢查询日志分析工具得到有问题的 SQL 列表
  - 4.2 执行计划分析， 重点关注type key rows filterd 等字段
  - 4.3 使用 show profile 工具
  
> 备注, **一些常见的sql优化规则**： 
- SQL 的查询一定要基于索引来进行数据扫描
- 避免索引列上使用函数或者运算,这样会导致索引失效
- where 字句中 like %号,尽量放置在右边
- 使用索引扫描,联合索引中的列从左往右,命中越多越好.
- 尽可能使用 SQL 语句用到的索引完成排序,避免使用文件排序的方式
- 查询有效的列信息即可.少用 * 代替列信息
- 永远用小结果集驱动大结果集。

## 03 对MVCC 的理解
- [一文理解Mysql MVCC](https://zhuanlan.zhihu.com/p/66791480)
- [看一遍就理解：MVCC原理详解](https://juejin.cn/post/7016165148020703246)

1. MVCC多版本并发控制！无锁化的方式实现对数据的并发访问
  - 已提交、可重复读 都是基于MVCC实现的
  - 读未提交，每次都读取最新的数据；串行化通过加锁的方式实现
2. MVCC的相关知识点：
  - 2.1 **事务版本号** ： 事务每次开启前，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。
  - 2.2 **隐式字段** ： 
     - row_id： 单调递增的行ID，不是必需的，占用6个字节。
     - trx_id： 记录操作该数据事务的事务ID
     - roll_pointer：指针，指向回滚段的undo日志 
  - 2.3   undo log，回滚日志；当delete一条记录时，undo log 中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。
    `InnoDB中通过undo log实现了数据的多版本，而并发控制通过锁来实现。`
    - undo logo 作用： 事务回滚时，保证原子性和一致性; 用于MVCC快照读。
  - 2.4 **版本链**
    - 多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为版本链。
  - 2.5  **快照读和当前读**
    - 快照读： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读, 
    - 当前读： 读取的是记录数据的最新版本，显式加锁的都是当前读。 如：`.....for update;  .....lock in share mode;`
  - 2.6** 读视图 Read View** 
    - 事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View。
    - 作用： 用来做可见性判断的，即判断当前事务可见哪个版本的数据
    > ReadView 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)
     它主要包含这样几部分：
     m_ids，当前有哪些事务正在执行，且还没有提交，这些事务的 id 就会存在这里；
     min_trx_id，是指 m_ids 里最小的值；
     max_trx_id，是指下一个要生成的事务 id。下一个要生成的事务 id 肯定比现在所有事务的 id 都大；
     creator_trx_id，每开启一个事务都会生成一个 ReadView，而 creator_trx_id 就是这个开启的事务的 id。
     一句话说：**当trx_id在m_ids中，或者大于m_ids列表中最大的事务id的时候，这个版本就不能被访问**。
 3. MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。  
 
 ## 04 Mysql 中的性能调优方法
 `下面四个优化成本递增`
 1. **表结构与索引**
     分库分表、读写分离、为字段选择合适的数据类型、适当的反范式设计，适当冗余设计、为查询操作创建必要的索引但是要避免索引滥用、尽可能使用 Not Null。
 2. **SQL 语句优化**
     通过慢查询分析需要优化的 SQL 进行合理优化、利用 explain、profile 等工具分析 SQL执行计划、避免使用 SELECT *查询。尽可能使用索引扫描来排序。
 3. **Mysql 参数优化**
     设置 Buffer_pool 的大小，建议占总内存的 70%左右设置刷盘策略，平衡好数据安全性和性能的关系等
 4. **硬件及系统配置**
      CPU 核数、磁盘的读写性能（减小寻道时间、旋转时间、传输时间），可以选择 SSD、网卡、内存等方面。