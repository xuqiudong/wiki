---
title: 03-MYSQL常见面试题
description: MYSQL常见面试题
published: true
date: 2023-08-23T09:18:54.274Z
tags: 咕泡, 面试
editor: markdown
dateCreated: 2023-08-23T07:11:38.907Z
---

# 03-MYSQL常见面试题

## 01 innoDB 如何解决幻读
[MySQL 幻读被彻底解决了吗★](https://blog.csdn.net/m0_71777195/article/details/126968432)
1. MYSQL的事务隔离级别：代表当存在多个事务并发冲突时，可能出现的脏读、不可重复读、幻读的问题。 (×：会差生，√：不会产生)
  | 事务隔离级别        | 脏读 |  不可重复读 | 幻读 | 
  |---                |---  | ---        | --- |
  | Read Uncommitted  |   √ |    √       | √   |
  | Read committed    |   × |    √       |  √  |
  | repeated read     |  ×  |    ×       |  很大程度避免  |
  | serializable      |   × |    ×       |  × |
  
2. 当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。
3. MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：
  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
   - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

> **快照读是如何避免幻读的？**
> 可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个  Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

> **当前读是如何避免幻读的？**
> MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。
这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。
另外，select ... for update 这种查询语句是当前读，每次执行的时候都是读取最新的数据。


3. 小结:
 - MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案：
  - 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。
 - 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。
> **举例了两个发生幻读场景的例子**。
> **第一个例子**：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。
**第二个例子**：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。
- 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。
- 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。

## 02 MYSQL性能优化
1. **硬件和操作系统层面的优化**
>  CPU、可用内存大小、磁盘读写速度、网络带宽
2. **架构设计层面的优化**
> MySQL 是一个磁盘 IO 访问量非常频繁的关系型数据库:
> 1. 搭建 Mysql 主从集群
> 2. 读写分离设计
> 3. 分库分表机制
> 4. 热点数据缓存
3.  **MySQL 程序配置优化**
>  my.cnf 中, 比如最大连接数， 开启binlog 日志，bufferPool等
>  注意：作用域
4.  **SQL 优化**
  - 4.1 慢 SQL 的定位和排查： 以通过慢查询日志和慢查询日志分析工具得到有问题的 SQL 列表
  - 4.2 执行计划分析， 重点关注type key rows filterd 等字段
  - 4.3 使用 show profile 工具
  
> 备注, **一些常见的sql用户规则**： 
- SQL 的查询一定要基于索引来进行数据扫描
- 避免索引列上使用函数或者运算,这样会导致索引失效
- where 字句中 like %号,尽量放置在右边
- 使用索引扫描,联合索引中的列从左往右,命中越多越好.
- 尽可能使用 SQL 语句用到的索引完成排序,避免使用文件排序的方式
- 查询有效的列信息即可.少用 * 代替列信息
- 永远用小结果集驱动大结果集。
