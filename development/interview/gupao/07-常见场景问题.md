---
title: 07-常见场景问题
description: 07-常见场景问题
published: true
date: 2023-09-25T08:06:49.351Z
tags: 咕泡, 场景, 面试
editor: markdown
dateCreated: 2023-09-22T09:46:05.755Z
---

# 07-常见场景问题

## 1. 订单超时自动取消功能如何设计
> 利用主流 MQ 中的延迟消息功能，消息发送到 Broker 上以后并不会立刻投递，而是根据消息中设置的延迟时间去投递。我们只需要把新的订单并计算这个订单的超时时间发送到 MQ 中即可。MQ 这种实现方式在性能、可扩展性、稳定性上都比较好，是一个不错的选择。
1. 定时轮询, 有延迟，数据库压力大
2. 惰性取消，查询时取消，影响查询效率
3. JDK延迟队列DelayQueue，
4. 时间轮：Netty的HashedWheelTimer；异常恢复困难，集群扩展麻烦，内存占用。
5. Redis过期回调：需要额外维护redis。
6. Redis有序集合：可能重复消费同一key。
7. 任务调度：使用任务调度中间件xxl-job、ScheduleX、Elastic-Job等来实现，设置一个调度时间cron，到达订单过期的调度时间时，触发任务执行取消订单业务逻辑。实现复杂，维护成本高。
8. 消息队列：使用RocketMQ、RabbitMQ、Kafka的延时消息，消息在发送到消息队列服务端后并不会立马投递，而是根据消息中的属性延迟固定时间后才投递给消费者。

## 02 怎么理解接口幂等? 如何保证的接口幂等
1. 幂等：一个接口，使用相同的参数重复执行的情况下，对数据造成的改变只发生一次。
2. 保证幂等就是：识别当前请求是重复请求：
  - 2.1 使用数据库唯一索引的方式实现
  - 2.2 使用 Redis 里面的 setNx 命令
  - 2.3 使用状态机的方式来实现幂等
  
## 03 消息推送中的已读消息和未读消息设计难题  
> “站内信”有两个基本功能：
> - 点到点的消息传送。用户给用户发送站内信，管理员给用户发送站内信。
> - 点到面的消息传送。管理员给用户（指定满足某一条件的用户群）群发消息

需要设计一个消息内容表和一个用户通知表，
当创建一条系统通知后，数据插入到消息内容表。消息内容包含了发送渠道，根据发送渠道决定后续动作。
如果是站内渠道，在插入消息内容后异步的插入记录到用户通知表。
**消息内容表**：id，标题，内容，类型，发送人，发送渠道(站内、短信、推送)
**用户通知表**：id，消息id，已读状态，接受者，类型

- 会带来两个问题：
  - 1. 随着用户量的增加，发送一次消息需要插入到数据库中的数据量会越来越大，导致耗时会越来越长
  - 2. 用户通知表的数据量会非常大，对未读消息的查询效率会严重下降
- 解决方案：
  - 方案一：
    - **先取消用户通知表**， 避免在发送平台消息的时候插入大量重复数据问题。  
    - **其次增加一个“message_offset”** 站内消息进度表，每个用户维护一个消息消费的进度 Offset。每个用户去获取未读消息的时候，只需要查询大于当前维护的 msg_id_offset 的数据即可。
    - 在这种设计方式中，即便我们发送给 10W 人，也只需要在消息内容表里面插入一条记录即可。在性能上和数据量上都有较大的提升。
  - 方案二：
    - 使用 Redis 中的 Set 集合来保存已经读取过的消息 id。使用 userid_read_message 作为 key，这样就可以为每个用户保存已经读取过的所有消息的 id。
    - 当用户读取了未读消息后， 就直接在 redis 的已读消息 id 的 set 中新增一条记录。
    - 这样，在已经得知到已读消息的数量和具体消息 id 的情况下，我们可以直接使用消息id 来查询没有消费过的数据。
    
 ## 04 布隆过滤器
1. 想判断一个元素是否存在某个集合里
2. BitMap 的基本原理就是用一个 bit 位来存储当前数据是否存在的状态值，也就是把一个数据通过 hash 运算取模后落在 bit 位组成的数组中，通过 1 对该位置进行标记。（适用于大规模数据，但数据状态又不是很多的情况）
3. 布隆过滤器就是在位图的基础上做的一个优化设计：它的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。
4. 检索的时候，使用同样的方式去映射，只要看到每个映射的位置的值是不是 1，就可以大概知道该元素是否存在集合中了。如果这些点有任何一个 0，则被检查的元素一定不在；如果都是 1，则被检查的元素很可能存在。
 